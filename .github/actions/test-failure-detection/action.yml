# ------------------------------------------------------------------------------------
#  Test Failure Detection (Composite Action)
#
#  Purpose: Define and provide reusable test failure detection functions for
#  robust test output parsing across different formats and test types.
#
#  This action provides sophisticated failure detection capabilities:
#    - JSON-based test output parsing (fast single-pass)
#    - Text-based failure detection with multiple patterns
#    - Detailed error capture and context preservation
#    - Fallback detection for edge cases
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: "Test Failure Detection"
description: "Provides robust test failure detection functions for JSON and text output parsing"

inputs:
  output-file:
    description: "Test output file to analyze"
    required: false
    default: "test-output.log"
  exit-code:
    description: "Test command exit code"
    required: false
    default: "0"
  mode:
    description: "Detection mode (json or text)"
    required: false
    default: "text"
  failures-file:
    description: "Output file for detected failures"
    required: false
    default: "test-failures.txt"

outputs:
  failure-count:
    description: "Number of detected test failures"
    value: ${{ steps.detect-failures.outputs.failure-count }}
  has-failures:
    description: "Boolean indicating if failures were detected"
    value: ${{ steps.detect-failures.outputs.has-failures }}
  detailed-failures-file:
    description: "Path to detailed failures file"
    value: ${{ steps.detect-failures.outputs.detailed-failures-file }}

runs:
  using: "composite"
  steps:
    - name: 🔧 Define failure detection functions
      shell: bash
      run: |
        # Define reusable function for robust test failure detection
        cat > test-failure-functions.sh << 'DETECTION_FUNCTIONS_EOF'
        #!/bin/bash

        # Robust test failure detection function
        detect_test_failures() {
          local output_file="$1"
          local exit_code="${2:-0}"
          local mode="${3:-text}"
          local failures_file="${4:-test-failures.txt}"

          echo "🔍 Detecting test failures with exit code: $exit_code, mode: $mode"

          # Primary check: exit code indicates failure
          if [[ "$exit_code" -ne 0 ]]; then
            echo "❌ Exit code $exit_code indicates test failure"

            if [[ -f "$output_file" ]]; then
              case "$mode" in
                "json")
                  # Enhanced JSON-based detection
                  detect_failures_from_json "$output_file" "$failures_file"
                  ;;
                "text"|*)
                  # Enhanced text-based detection
                  detect_failures_from_text "$output_file" "$failures_file"
                  ;;
              esac

              # Count detected failures
              if [[ -f "$failures_file" ]]; then
                DETECTED_FAILURES=$(wc -l < "$failures_file" 2>/dev/null || echo "0")
                echo "📊 Detected $DETECTED_FAILURES specific failures"
                return $DETECTED_FAILURES
              fi
            else
              echo "⚠️ Output file '$output_file' not found, relying on exit code"
              echo "Exit code indicates failure but no output file found" > "$failures_file"
              return 1
            fi
          else
            echo "✅ Exit code 0 indicates success"
            touch "$failures_file"  # Create empty failures file
            return 0
          fi
        }

        # Smart and efficient JSON failure detection with unique signatures
        detect_failures_from_json() {
          local json_file="$1"
          local failures_file="$2"
          local signatures_file="${failures_file%.txt}-signatures.json"

          echo "🔍 Using smart JSON-based failure detection on $json_file"

          # Quick JSON validation (< 0.1s) - check if file contains JSON test output
          if ! grep -q '^{.*"Action"' "$json_file" 2>/dev/null; then
            echo "⚠️ No JSON content detected, using text fallback"
            detect_failures_from_text "$json_file" "$failures_file"
            return
          fi

          echo "✅ JSON content detected, processing efficiently..."

          # Initialize JSON array for structured failures with signatures
          echo '[]' > "$signatures_file"

          # Fast single-pass JSON extraction for test failures with line numbers (< 1s for 10K lines)
          # Filter JSON lines and parse in one pass - eliminates 2-minute hang
          # Extract line numbers from Output field when available
          grep '^{' "$json_file" 2>/dev/null | \
            jq -r 'select(.Action == "fail") |
              if (.Output and .Output != null and .Output != "") then
                # Try to extract file:line from Output field
                (.Output | match("([^:]+\\.go):(\\d+):"; "g") |
                  "--- FAIL: \(if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end) (\(.Package):\(.captures[1].string))")
                // "--- FAIL: \(if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end) (\(.Package))"
              else
                "--- FAIL: \(if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end) (\(.Package))"
              end' \
            2>/dev/null > "$failures_file"

          # Create structured test failure entries with unique signatures
          if grep '^{' "$json_file" 2>/dev/null | jq -r 'select(.Action == "fail")' 2>/dev/null | head -1 | grep -q .; then
            echo "📝 Creating structured test failure entries..."
            grep '^{' "$json_file" 2>/dev/null | \
              jq -r 'select(.Action == "fail") | {
                type: "test",
                package: .Package,
                test: (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end),
                output: .Output // "",
                line_number: (if (.Output and .Output != null and .Output != "") then (.Output | match("([^:]+\\.go):(\\d+):"; "g") | .captures[1].string) // null else null end),
                signature: (.Package + ":" + (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end)),
                unique_id: (.Package + ":" + (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end) | gsub("[^a-zA-Z0-9_/.-]"; "_"))
              }' 2>/dev/null | \
              jq -s '.' >> "$signatures_file.tmp" 2>/dev/null && \
              mv "$signatures_file.tmp" "$signatures_file" || echo '[]' > "$signatures_file"
          fi

          # Also check for build failures which have FailedBuild field but no Test field
          local build_failures
          build_failures=$(grep '^{' "$json_file" 2>/dev/null | \
            jq -r 'select(.FailedBuild) | .Package // .ImportPath' 2>/dev/null | sort -u)

          if [[ -n "$build_failures" ]]; then
            echo "🔨 Processing build failures with signatures..."

            # Create temporary array for build failures
            echo '[]' > "${signatures_file}.build"

            while IFS= read -r pkg; do
              if [[ -n "$pkg" ]]; then
                echo "--- BUILD FAILED: $pkg" >> "$failures_file"

                # Extract build error messages for this package
                local build_errors
                build_errors=$(grep '^{' "$json_file" 2>/dev/null | \
                  jq -r --arg pkg "$pkg" 'select(.ImportPath and (.ImportPath | startswith($pkg + " ")) and .Action == "build-output") | .Output' 2>/dev/null | \
                  grep -E "^[^[:space:]]" | head -10)  # Limit to first 10 error lines

                local error_output=""
                if [[ -n "$build_errors" ]]; then
                  echo "$build_errors" | sed 's/^/    /' >> "$failures_file"
                  error_output="$build_errors"
                else
                  echo "    Build failed (no detailed error available)" >> "$failures_file"
                  error_output="Build failed (no detailed error available)"
                fi

                # Create structured build failure entry
                jq -n --arg pkg "$pkg" --arg errors "$error_output" '{
                  type: "build",
                  package: $pkg,
                  test: "build_compilation",
                  output: $errors,
                  signature: ($pkg + ":build_compilation"),
                  unique_id: ($pkg + ":build_compilation" | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                }' >> "${signatures_file}.build" 2>/dev/null
              fi
            done <<< "$build_failures"

            # Merge build failures into main signatures file
            if [[ -s "${signatures_file}.build" ]]; then
              jq -s 'add' "$signatures_file" "${signatures_file}.build" > "${signatures_file}.tmp" 2>/dev/null && \
                mv "${signatures_file}.tmp" "$signatures_file" || echo '[]' > "$signatures_file"
            fi
            rm -f "${signatures_file}.build"
          fi

          local failure_count
          failure_count=$(wc -l < "$failures_file" 2>/dev/null | tr -d '\n\r' | xargs)
          [[ "$failure_count" =~ ^[0-9]+$ ]] || failure_count=0

          # Count distinct failures (test failures + build failures)
          local test_failure_count build_failure_count
          test_failure_count=$(grep -c "^--- FAIL:" "$failures_file" 2>/dev/null || echo "0")
          build_failure_count=$(grep -c "^--- BUILD FAILED:" "$failures_file" 2>/dev/null || echo "0")

          # Validate signatures file
          local unique_failure_count=0
          if [[ -s "$signatures_file" ]]; then
            unique_failure_count=$(jq 'length' "$signatures_file" 2>/dev/null || echo "0")
            echo "📊 Generated $unique_failure_count unique failure signatures"
          fi

          if [[ $test_failure_count -gt 0 ]] || [[ $build_failure_count -gt 0 ]]; then
            echo "✅ Found $test_failure_count test failures and $build_failure_count build failures in JSON output"
            echo "🔍 Created $unique_failure_count unique signatures for deduplication"
            return 0
          else
            echo "ℹ️ No failures detected in JSON output"
            return 0
          fi
        }

        # Enhanced text-based failure detection with signatures
        detect_failures_from_text() {
          local text_file="$1"
          local failures_file="$2"
          local detailed_failures_file="${failures_file%.txt}-detailed.txt"
          local signatures_file="${failures_file%.txt}-signatures.json"

          echo "🔍 Using enhanced text-based failure detection on $text_file"

          # Initialize JSON array for structured failures with signatures
          echo '[]' > "$signatures_file"

          # Enhanced pattern matching for various failure formats
          # Patterns handle: FAIL, --- FAIL, --FAIL, [FAIL], FAIL:, etc.
          local patterns=(
            '^FAIL[[:space:]:]'
            '^---[[:space:]]*FAIL'
            '^--[[:space:]]*FAIL'
            '^\[?FAIL\]?[[:space:]:.]'
            '--- FAIL:'
            'FAIL[[:space:]]*:'
            '^[[:space:]]*FAIL[[:space:]]'
          )

          local temp_failures=$(mktemp)
          local temp_detailed=$(mktemp)
          local found_any=false

          # First pass: Find all failure lines and capture context
          for pattern in "${patterns[@]}"; do
            if grep -E -A 15 "$pattern" "$text_file" >> "$temp_detailed" 2>/dev/null; then
              found_any=true
              # Also capture just the failure line for the summary
              grep -E "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null || true
            fi
          done

          if [[ "$found_any" == "true" ]]; then
            # Process the detailed failures to create structured output
            echo "🔍 Processing detailed failure output..."

            # Create a structured detailed failures file with error messages
            awk '
              BEGIN {
                current_test = ""
                capture_output = 0
                output_buffer = ""
              }
              /^(FAIL|---.*FAIL|--.*FAIL|\[?FAIL\]?)/ {
                # If we were capturing output, save it
                if (current_test != "" && output_buffer != "") {
                  print "TEST:" current_test
                  print "ERROR:" output_buffer
                  print "---SEPARATOR---"
                }

                # Start new test capture
                current_test = $0
                output_buffer = ""
                capture_output = 1
                next
              }
              capture_output == 1 && /^[[:space:]]*$/ {
                # Empty line might end the error context
                if (length(output_buffer) > 100) capture_output = 0
                next
              }
              capture_output == 1 && !/^(PASS|ok |FAIL|---.*FAIL|--.*FAIL)/ {
                # Capture error output lines
                if (output_buffer == "") {
                  output_buffer = $0
                } else {
                  output_buffer = output_buffer "\n" $0
                }
                # Stop if we have captured enough context
                if (length(output_buffer) > 1500) capture_output = 0
              }
              /^(PASS|ok )/ && capture_output == 1 {
                # Another test started, stop capturing
                capture_output = 0
              }
              END {
                # Save the last test if we were capturing
                if (current_test != "" && output_buffer != "") {
                  print "TEST:" current_test
                  print "ERROR:" output_buffer
                  print "---SEPARATOR---"
                }
              }
            ' "$temp_detailed" > "$detailed_failures_file" 2>/dev/null || true

            # Remove duplicates and sort for the summary file
            sort -u "$temp_failures" > "$failures_file"

            # Generate signatures from text failures
            echo "📝 Generating failure signatures from text output..."
            local temp_signatures=$(mktemp)
            echo '[]' > "$temp_signatures"

            while IFS= read -r failure_line; do
              if [[ -n "$failure_line" && "$failure_line" != *"Generic test failure"* ]]; then
                # Extract package and test info from failure line
                # Pattern: --- FAIL: TestName (package.name) or --- FAIL: TestName (package.name:123)
                if [[ "$failure_line" =~ "FAIL:" ]]; then
                  local test_name=$(echo "$failure_line" | sed -E 's/^.*FAIL: ([^ ]+).*$/\1/' | head -c 200)
                  local package_name=$(echo "$failure_line" | sed -E 's/^.*\(([^):]+)[^)]*\).*$/\1/' | head -c 200)
                  local line_number=$(echo "$failure_line" | sed -E 's/^.*\([^:]+:([0-9]+)\).*$/\1/' | head -c 10)
                  # If line_number extraction didn't work, it will be same as input - set to empty
                  [[ "$line_number" == "$failure_line" ]] && line_number=""

                  # Handle build failures
                  if [[ "$failure_line" =~ "BUILD FAILED:" ]]; then
                    package_name=$(echo "$failure_line" | sed 's/^--- BUILD FAILED: //' | head -c 200)
                    test_name="build_compilation"

                    jq -n --arg pkg "$package_name" --arg test "$test_name" --arg output "$failure_line" '{
                      type: "build",
                      package: $pkg,
                      test: $test,
                      output: $output,
                      line_number: null,
                      signature: ($pkg + ":" + $test),
                      unique_id: (($pkg + ":" + $test) | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                    }' >> "$temp_signatures.items"
                  else
                    # Regular test failure
                    if [[ -n "$test_name" && -n "$package_name" && "$test_name" != "$package_name" ]]; then
                      jq -n --arg pkg "$package_name" --arg test "$test_name" --arg output "$failure_line" --arg line "$line_number" '{
                        type: "test",
                        package: $pkg,
                        test: $test,
                        output: $output,
                        line_number: (if ($line != "") then ($line | tonumber) else null end),
                        signature: ($pkg + ":" + $test),
                        unique_id: (($pkg + ":" + $test) | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                      }' >> "$temp_signatures.items"
                    fi
                  fi
                fi
              fi
            done < "$failures_file"

            # Combine signatures into array
            if [[ -f "$temp_signatures.items" ]]; then
              jq -s '.' "$temp_signatures.items" > "$signatures_file" 2>/dev/null || echo '[]' > "$signatures_file"
            fi
            rm -f "$temp_signatures" "$temp_signatures.items"

            local unique_signature_count=$(jq 'length' "$signatures_file" 2>/dev/null || echo "0")
            echo "✅ Text parsing found $(wc -l < "$failures_file") failures with $unique_signature_count unique signatures"

            # Clean up
            rm -f "$temp_failures" "$temp_detailed"
            return 0
          fi

          # Fallback: look for any error indicators
          echo "⚠️ Standard failure patterns not found, checking for error indicators"
          local error_patterns=(
            'panic:'
            'fatal error:'
            'build failed'
            'compilation error'
            'timeout'
            'killed'
            'error:'
          )

          for pattern in "${error_patterns[@]}"; do
            if grep -i -A 5 "$pattern" "$text_file" >> "$temp_detailed" 2>/dev/null; then
              found_any=true
              grep -i "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null || true
            fi
          done

          if [[ "$found_any" == "true" ]]; then
            sort -u "$temp_failures" > "$failures_file"
            cp "$temp_detailed" "$detailed_failures_file" 2>/dev/null || true
            echo "⚠️ Found $(wc -l < "$failures_file") error indicators (not standard test failures)"
            rm -f "$temp_failures" "$temp_detailed"
            return 0
          fi

          rm -f "$temp_failures" "$temp_detailed"

          # If exit code indicated failure but no patterns found, create generic entry
          if [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]]; then
            echo "Generic test failure (exit code ${TEST_EXIT_CODE:-0}) - pattern detection failed" > "$failures_file"
            echo "⚠️ Exit code indicates failure but no recognizable patterns found"
            return 1
          else
            touch "$failures_file"  # Create empty failures file
            echo "✅ No failures detected and exit code is 0"
            return 0
          fi
        }

        # Utility function for safe numeric validation
        sanitize_numeric() {
          local value="$1"
          value=$(echo "$value" | tr -d '\n\r' | xargs)
          if [[ "$value" =~ ^[0-9]+$ ]]; then
            echo "$value"
          else
            echo "0"
          fi
        }

        # Export functions for use in other steps
        export -f detect_test_failures
        export -f detect_failures_from_json
        export -f detect_failures_from_text
        export -f sanitize_numeric
        DETECTION_FUNCTIONS_EOF

        # Source the functions to make them available
        source test-failure-functions.sh
        echo "✅ Failure detection functions defined and loaded"

    - name: 🔍 Detect test failures
      id: detect-failures
      shell: bash
      run: |
        # Source the functions
        source test-failure-functions.sh

        # Run detection with provided inputs
        OUTPUT_FILE="${{ inputs.output-file }}"
        EXIT_CODE="${{ inputs.exit-code }}"
        MODE="${{ inputs.mode }}"
        FAILURES_FILE="${{ inputs.failures-file }}"

        # Detect failures
        detect_test_failures "$OUTPUT_FILE" "$EXIT_CODE" "$MODE" "$FAILURES_FILE"
        detection_result=$?

        # Calculate outputs
        if [[ -f "$FAILURES_FILE" ]]; then
          FAILURE_COUNT=$(wc -l < "$FAILURES_FILE" 2>/dev/null | tr -d '\n\r' | xargs)
          FAILURE_COUNT=$(sanitize_numeric "$FAILURE_COUNT")
        else
          FAILURE_COUNT=0
        fi

        HAS_FAILURES="false"
        if [[ "$FAILURE_COUNT" -gt 0 ]] || [[ "$detection_result" -ne 0 ]]; then
          HAS_FAILURES="true"
        fi

        DETAILED_FILE="${FAILURES_FILE%.txt}-detailed.txt"

        # Set outputs
        echo "failure-count=$FAILURE_COUNT" >> $GITHUB_OUTPUT
        echo "has-failures=$HAS_FAILURES" >> $GITHUB_OUTPUT
        echo "detailed-failures-file=$DETAILED_FILE" >> $GITHUB_OUTPUT

        echo "📊 Failure detection results:"
        echo "   • Failure count: $FAILURE_COUNT"
        echo "   • Has failures: $HAS_FAILURES"
        echo "   • Detailed file: $DETAILED_FILE"
